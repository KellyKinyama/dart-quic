// In file: hex_dump2.dart

// Make sure to import the new file
import 'buffer.dart';
import 'quic_header.dart'; 
import 'dart:typed_data';
import 'dart:math';

import 'package:hex/hex.dart';

import 'aead.dart';
import 'header_protector.dart';
import 'payload_parser_final.dart';
// import 'payload_parser9.dart';
import 'protocol.dart';
import 'initial_aead.dart';
import 'quic_frame_parser.dart';
// Rename this function to be more generic, as it works for any long header packet
void unprotectAndParseLongHeaderPacket(
  Uint8List packetBytes,
  LongHeaderOpener opener,
) {
  print('\n--- Parsing Long Header Packet ---');
  final mutablePacket = Uint8List.fromList(packetBytes);
  final buffer = Buffer(data: mutablePacket);
  
  // 1. Use the new robust header parser
  final header = pullQuicLongHeader(buffer);
  
  print('DEBUG: Parsed Packet Type: ${header.packetType}');
  print('DEBUG: Parsed DCID (Hex): ${HEX.encode(header.destinationCid)}');
  print('DEBUG: Parsed SCID (Hex): ${HEX.encode(header.sourceCid)}');
  print('DEBUG: Packet Number starts at offset: ${header.pnOffset}');
  print('DEBUG: Payload Length Field (Decimal): ${header.payloadLength}');

  // 2. Header protection logic remains the same
  final sample = Uint8List.view(mutablePacket.buffer, header.pnOffset + 4, 16);
  final firstByteView = Uint8List.view(mutablePacket.buffer, 0, 1);
  // We don't know the PN length yet, so we pass a 4-byte view and let the AEAD use what it needs
  final protectedPnBytesView = Uint8List.view(mutablePacket.buffer, header.pnOffset, 4);


  opener.decryptHeader(sample, firstByteView, protectedPnBytesView);

  // 3. Packet number and payload logic now uses the correct values from the parsed header
  final pnLength = (firstByteView[0] & 0x03) + 1;
  int wirePn = 0;
  for (int i = 0; i < pnLength; i++) {
    wirePn = (wirePn << 8) | protectedPnBytesView[i];
  }
  print('DEBUG: Decoded Packet Number Length: $pnLength bytes');
  print('DEBUG: Decoded Packet Number on the wire: $wirePn');

  final fullPacketNumber = opener.decodePacketNumber(wirePn, pnLength);
  final payloadOffset = header.pnOffset + pnLength;
  final associatedData = Uint8List.view(mutablePacket.buffer, 0, payloadOffset);
  final ciphertext = Uint8List.view(
    mutablePacket.buffer,
    payloadOffset,
    header.payloadLength - pnLength,
  );

  // 4. Decryption should now succeed
  try {
    final plaintext = opener.open(ciphertext, fullPacketNumber, associatedData);
    print('✅ **Payload decrypted successfully!**');
    // ... rest of your frame parsing logic ...
  } catch (e, s) {
    print('\n❌ ERROR: Decryption failed.');
    print('Exception: $e');
    print('Stack trace:\n$s');
  }
}

void main(){  

   final (_, opener) = newInitialAEAD(
    dcid,
    Perspective.server,
    Version.version1,
  );
  unprotectAndParseLongHeaderPacket(clientIntialBytes, opener);
}


final clientIntialBytes = Uint8List.fromList([
  0xcf,
  0x00,
  0x00,
  0x00,
  0x01,
  0x05,
  0x73,
  0x5f,
  0x63,
  0x69,
  0x64,
  0x05,
  0x63,
  0x5f,
  0x63,
  0x69,
  0x64,
  0x00,
  0x40,
  0x17,
  0x56,
  0x6e,
  0x1f,
  0x98,
  0xed,
  0x1f,
  0x7b,
  0x05,
  0x55,
  0xcd,
  0xb7,
  0x83,
  0xfb,
  0xdf,
  0x5b,
  0x52,
  0x72,
  0x4b,
  0x7d,
  0x29,
  0xf0,
  0xaf,
  0xe3,
]);

final ch = Uint8List.fromList([
  0x01,
  0x00,
  0x00,
  0xea,
  0x03,
  0x03,
  0x00,
  0x01,
  0x02,
  0x03,
  0x04,
  0x05,
  0x06,
  0x07,
  0x08,
  0x09,
  0x0a,
  0x0b,
  0x0c,
  0x0d,
  0x0e,
  0x0f,
  0x10,
  0x11,
  0x12,
  0x13,
  0x14,
  0x15,
  0x16,
  0x17,
  0x18,
  0x19,
  0x1a,
  0x1b,
  0x1c,
  0x1d,
  0x1e,
  0x1f,
  0x00,
  0x00,
  0x06,
  0x13,
  0x01,
  0x13,
  0x02,
  0x13,
  0x03,
  0x01,
  0x00,
  0x00,
  0xbb,
  0x00,
  0x00,
  0x00,
  0x18,
  0x00,
  0x16,
  0x00,
  0x00,
  0x13,
  0x65,
  0x78,
  0x61,
  0x6d,
  0x70,
  0x6c,
  0x65,
  0x2e,
  0x75,
  0x6c,
  0x66,
  0x68,
  0x65,
  0x69,
  0x6d,
  0x2e,
  0x6e,
  0x65,
  0x74,
  0x00,
  0x0a,
  0x00,
  0x08,
  0x00,
  0x06,
  0x00,
  0x1d,
  0x00,
  0x17,
  0x00,
  0x18,
  0x00,
  0x10,
  0x00,
  0x0b,
  0x00,
  0x09,
  0x08,
  0x70,
  0x69,
  0x6e,
  0x67,
  0x2f,
  0x31,
  0x2e,
  0x30,
  0x00,
  0x0d,
  0x00,
  0x14,
  0x00,
  0x12,
  0x04,
  0x03,
  0x08,
  0x04,
  0x04,
  0x01,
  0x05,
  0x03,
  0x08,
  0x05,
  0x05,
  0x01,
  0x08,
  0x06,
  0x06,
  0x01,
  0x02,
  0x01,
  0x00,
  0x33,
  0x00,
  0x26,
  0x00,
  0x24,
  0x00,
  0x1d,
  0x00,
  0x20,
  0x35,
  0x80,
  0x72,
  0xd6,
  0x36,
  0x58,
  0x80,
  0xd1,
  0xae,
  0xea,
  0x32,
  0x9a,
  0xdf,
  0x91,
  0x21,
  0x38,
  0x38,
  0x51,
  0xed,
  0x21,
  0xa2,
  0x8e,
  0x3b,
  0x75,
  0xe9,
  0x65,
  0xd0,
  0xd2,
  0xcd,
  0x16,
  0x62,
  0x54,
  0x00,
  0x2d,
  0x00,
  0x02,
  0x01,
  0x01,
  0x00,
  0x2b,
  0x00,
  0x03,
  0x02,
  0x03,
  0x04,
  0x00,
  0x39,
  0x00,
  0x31,
  0x03,
  0x04,
  0x80,
  0x00,
  0xff,
  0xf7,
  0x04,
  0x04,
  0x80,
  0xa0,
  0x00,
  0x00,
  0x05,
  0x04,
  0x80,
  0x10,
  0x00,
  0x00,
  0x06,
  0x04,
  0x80,
  0x10,
  0x00,
  0x00,
  0x07,
  0x04,
  0x80,
  0x10,
  0x00,
  0x00,
  0x08,
  0x01,
  0x0a,
  0x09,
  0x01,
  0x0a,
  0x0a,
  0x01,
  0x03,
  0x0b,
  0x01,
  0x19,
  0x0f,
  0x05,
  0x63,
  0x5f,
  0x63,
  0x69,
  0x64,
]);

final sh = Uint8List.fromList([
  0x02,
  0x00,
  0x00,
  0x56,
  0x03,
  0x03,
  0x70,
  0x71,
  0x72,
  0x73,
  0x74,
  0x75,
  0x76,
  0x77,
  0x78,
  0x79,
  0x7a,
  0x7b,
  0x7c,
  0x7d,
  0x7e,
  0x7f,
  0x80,
  0x81,
  0x82,
  0x83,
  0x84,
  0x85,
  0x86,
  0x87,
  0x88,
  0x89,
  0x8a,
  0x8b,
  0x8c,
  0x8d,
  0x8e,
  0x8f,
  0x00,
  0x13,
  0x01,
  0x00,
  0x00,
  0x2e,
  0x00,
  0x33,
  0x00,
  0x24,
  0x00,
  0x1d,
  0x00,
  0x20,
  0x9f,
  0xd7,
  0xad,
  0x6d,
  0xcf,
  0xf4,
  0x29,
  0x8d,
  0xd3,
  0xf9,
  0x6d,
  0x5b,
  0x1b,
  0x2a,
  0xf9,
  0x10,
  0xa0,
  0x53,
  0x5b,
  0x14,
  0x88,
  0xd7,
  0xf8,
  0xfa,
  0xbb,
  0x34,
  0x9a,
  0x98,
  0x28,
  0x80,
  0xb6,
  0x15,
  0x00,
  0x2b,
  0x00,
  0x02,
  0x03,
  0x04,
]);
