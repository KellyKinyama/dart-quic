// main_quic_handshake.dart
import 'dart:typed_data';
import 'dart:convert';
import 'protocol.dart';
import 'initial_aead.dart';
import 'aead.dart';

// Dummy representation of a QUIC Packet. In a real-world scenario, this
// would be a complex structure with a full header and frames.
class QuicPacket {
  final EncryptionLevel level;
  final Uint8List payload;
  final Uint8List header;

  QuicPacket(this.level, this.header, this.payload);
}

enum EncryptionLevel { initial, handshake, oneRtt }

// Dummy function to simulate a TLS handshake message.
// In a real implementation, this would be generated by a TLS stack.
Uint8List createTlsMessage(String type) {
  return Uint8List.fromList(utf8.encode(type));
}

// Dummy function to simulate parsing a TLS message.
String parseTlsMessage(Uint8List message) {
  return utf8.decode(message);
}

// --- Client Implementation ---
class QuicClient {
  late LongHeaderSealer _initialSealer;
  late LongHeaderOpener _initialOpener;
  late LongHeaderSealer _handshakeSealer;
  late LongHeaderOpener _handshakeOpener;
  
  // These would be derived from the TLS handshake in a real implementation
  Uint8List _clientTrafficSecret = Uint8List(0);
  Uint8List _serverTrafficSecret = Uint8List(0);

  QuicClient() {
    // Client Connection ID is typically provided by the client
    final connID = Uint8List.fromList([1, 2, 3, 4, 5, 6, 7, 8]);
    final version = Version.version1;
    final (sealer, opener) = newInitialAEAD(connID, Perspective.client, version);
    _initialSealer = sealer;
    _initialOpener = opener;
  }

  // Step 1: Client sends the Initial packet with ClientHello.
  QuicPacket sendInitialClientHello() {
    final clientHelloMsg = createTlsMessage('ClientHello');
    final ad = Uint8List.fromList([0x40, 0, 0, 0]); // dummy associated data
    
    // Header protection and encryption with Initial keys.
    final header = Uint8List.fromList([0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    final firstByte = header.sublist(0, 1);
    final pnBytes = header.sublist(9, 13);
    
    final encryptedPayload = _initialSealer.seal(clientHelloMsg, 0x1, ad);
    _initialSealer.encryptHeader(encryptedPayload.sublist(4, 20), firstByte, pnBytes);
    
    print('Client: Sending Initial packet with ClientHello.');
    return QuicPacket(EncryptionLevel.initial, header, encryptedPayload);
  }

  // Step 2: Client receives server's packets and moves to Handshake keys.
  void receiveServerHandshake(QuicPacket packet) {
    // Decrypt and unprotect header
    final header = Uint8List.fromList(packet.header);
    final firstByte = header.sublist(0, 1);
    final pnBytes = header.sublist(9, 13);
    final sample = packet.payload.sublist(4, 20);
    _initialOpener.decryptHeader(sample, firstByte, pnBytes);

    // Decrypt payload
    final decryptedPayload = _initialOpener.open(packet.payload, 0x1, Uint8List.fromList([0x40, 0, 0, 0]));
    
    final tlsMessage = parseTlsMessage(decryptedPayload);
    print('Client: Received and decrypted message: $tlsMessage');
    
    // Assuming the TLS stack now provides the Handshake keys.
    // In a real scenario, this would involve key derivation.
    _clientTrafficSecret = Uint8List.fromList(utf8.encode('client-handshake-secret'));
    _serverTrafficSecret = Uint8List.fromList(utf8.encode('server-handshake-secret'));

    // Create a new sealer/opener with handshake keys.
    // The nonce masks and keys would be generated by the TLS stack.
    final handshakeKey = Uint8List.fromList([/* ... */]);
    final handshakeIV = Uint8List.fromList([/* ... */]);
    final handshakeNonceMask = Uint8List.fromList([/* ... */]);
    
    _handshakeSealer = LongHeaderSealer(
      initialSuite.aead(key: handshakeKey, nonceMask: handshakeNonceMask),
      newHeaderProtector(initialSuite, _clientTrafficSecret, true, Version.version1),
    );
    _handshakeOpener = LongHeaderOpener(
      initialSuite.aead(key: handshakeKey, nonceMask: handshakeNonceMask),
      newHeaderProtector(initialSuite, _serverTrafficSecret, true, Version.version1),
    );
  }
}

// --- Server Implementation ---
class QuicServer {
  late LongHeaderSealer _initialSealer;
  late LongHeaderOpener _initialOpener;
  late LongHeaderSealer _handshakeSealer;
  late LongHeaderOpener _handshakeOpener;
  
  // These would be derived from the TLS handshake in a real implementation
  Uint8List _clientTrafficSecret = Uint8List(0);
  Uint8List _serverTrafficSecret = Uint8List(0);

  QuicServer() {
    // Server has a connection ID but doesn't need to specify it initially
    // as it's provided by the client's first packet.
  }

  // Step 1: Server receives the client's Initial packet.
  QuicPacket receiveInitialPacket(QuicPacket packet) {
    final connID = Uint8List.fromList([1, 2, 3, 4, 5, 6, 7, 8]); // get from client header
    final version = Version.version1;
    final (sealer, opener) = newInitialAEAD(connID, Perspective.server, version);
    _initialSealer = sealer;
    _initialOpener = opener;
    
    // Decrypt and unprotect header
    final header = Uint8List.fromList(packet.header);
    final firstByte = header.sublist(0, 1);
    final pnBytes = header.sublist(9, 13);
    final sample = packet.payload.sublist(4, 20);
    _initialOpener.decryptHeader(sample, firstByte, pnBytes);
    
    // Decrypt payload
    final decryptedPayload = _initialOpener.open(packet.payload, 0x1, Uint8List.fromList([0x40, 0, 0, 0]));
    final tlsMessage = parseTlsMessage(decryptedPayload);
    print('Server: Received and decrypted message: $tlsMessage');
    
    // Step 2: Server responds with ServerHello (Initial) and Handshake (EncryptedExtensions, Finished).
    _clientTrafficSecret = Uint8List.fromList(utf8.encode('client-handshake-secret'));
    _serverTrafficSecret = Uint8List.fromList(utf8.encode('server-handshake-secret'));

    // Create a new sealer/opener for handshake keys.
    final handshakeKey = Uint8List.fromList([/* ... */]);
    final handshakeIV = Uint8List.fromList([/* ... */]);
    final handshakeNonceMask = Uint8List.fromList([/* ... */]);

    _handshakeSealer = LongHeaderSealer(
      initialSuite.aead(key: handshakeKey, nonceMask: handshakeNonceMask),
      newHeaderProtector(initialSuite, _serverTrafficSecret, true, Version.version1),
    );
    
    // This is a simplified response. A real response would be a coalesced packet
    // containing both Initial (ServerHello) and Handshake (EncryptedExtensions, Finished) messages.
    final serverHelloMsg = createTlsMessage('ServerHello');
    final ad = Uint8List.fromList([0x40, 0, 0, 0]);
    final initialHeader = Uint8List.fromList([0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    final firstByte = initialHeader.sublist(0, 1);
    final pnBytes = initialHeader.sublist(9, 13);
    final encryptedInitialPayload = _initialSealer.seal(serverHelloMsg, 0x2, ad);
    _initialSealer.encryptHeader(encryptedInitialPayload.sublist(4, 20), firstByte, pnBytes);
    
    print('Server: Sending Initial packet with ServerHello.');
    return QuicPacket(EncryptionLevel.initial, initialHeader, encryptedInitialPayload);
  }
}

void main() {
  print('--- Starting QUIC Handshake Simulation ---');
  final client = QuicClient();
  final server = QuicServer();
  
  // Client initiates the handshake.
  final clientInitialPacket = client.sendInitialClientHello();
  
  // Server processes the client's packet and responds.
  final serverInitialPacket = server.receiveInitialPacket(clientInitialPacket);
  
  // Client processes the server's response.
  client.receiveServerHandshake(serverInitialPacket);

  print('--- Handshake Completed ---');
}