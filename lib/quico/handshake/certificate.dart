import 'dart:typed_data';

import 'package:hex/hex.dart';

import 'extensions/extensions.dart';
import 'handshake.dart';
import '../buffer.dart';

enum CertificateType {
  X509(0),
  RawPublicKey(2),
  Unknown(255);

  const CertificateType(this.value);
  final int value;

  factory CertificateType.fromValue(int key) {
    return values.firstWhere((element) => element.value == key);
  }
}

class CertificateEntry {
  final Uint8List certData;
  final List<Extension> extensions;

  CertificateEntry(this.certData, this.extensions);

  factory CertificateEntry.fromBytes(Buffer buffer) {
    final certType = CertificateType.fromValue(buffer.pullUint8());
    if (certType != CertificateType.X509) {
      // only X509 certificate is supported.
      throw Exception("UnsupportedCertificate");
    }
    final certLen = buffer.pullUint16();
    final cert = buffer.pullBytes(certLen);
    final ext = parseExtensions(buffer, messageType: HandshakeType.certificate.value);
    return CertificateEntry(cert, ext);
  }

  // pub fn decode(reader: anytype, allocator: std.mem.Allocator) !Self {
  //         // Decoding certificate_type.
  //         const cert_type = try reader.readInt(u8, .big); // CertificateType
  //         if (cert_type != 0) {
  //             // only X509 certificate is supported.
  //             return Error.UnsupportedCertificate;
  //         }

  //         // Decoding certificate.
  //         const cert_len = try reader.readInt(u16, .big);
  //         const cert = try x509.Certificate.decode(reader, allocator);
  //         errdefer cert.deinit();

  //         // Decoding extensions.
  //         var exts = ArrayList(Extension).init(allocator);
  //         try msg.decodeExtensions(reader, allocator, &exts, .server_hello, false);

  //         return Self{
  //             .cert = cert,
  //             .cert_len = cert_len,
  //             .extensions = exts,
  //             .allocator = allocator,
  //         };
  //     }

  /// ## NEW IMPLEMENTATION ##
  /// Serializes this certificate entry to bytes according to the TLS 1.3 spec.
  Uint8List toBytes() {
    final buffer = Buffer();

    // Serialize the certificate data with a 3-byte length prefix.
    buffer.pushVector(certData, 3);

    // Serialize all extensions into a temporary buffer first.
    final extensionsBuffer = Buffer();
    for (final ext in extensions) {
      // This assumes that each of your 'Extension' subclasses
      // has a correctly implemented toBytes() method.
      extensionsBuffer.pushBytes(ext.toBytes());
    }

    // Write the serialized extensions with a 2-byte length prefix.
    buffer.pushVector(extensionsBuffer.toBytes(), 2);

    return buffer.toBytes();
  }

  @override
  String toString() =>
      'CertificateEntry(len: ${certData.length}, extensions: ${extensions.length})';
}

class Certificate extends TlsHandshakeMessage {
  final Uint8List certificateRequestContext;
  final List<CertificateEntry> certificateList;
  Certificate({
    required this.certificateRequestContext,
    required this.certificateList,
  }) : super(11);

  factory Certificate.fromBytes(Buffer buffer) {
    final contextLen = buffer.pullUint8();
    final context = buffer.pullBytes(contextLen);
    final certListBytes = buffer.pullVector(3);
    final certListBuffer = Buffer(data: certListBytes);
    final certs = <CertificateEntry>[];
    while (!certListBuffer.eof) {
      certs.add(
        CertificateEntry(
          certListBuffer.pullVector(3),
          parseExtensions(
            certListBuffer,
            messageType: HandshakeType.certificate.value,
          ),
        ),
      );
    }
    return Certificate(
      certificateRequestContext: context,
      certificateList: certs,
    );
  }
  @override
  Uint8List toBytes() {
    final buffer = Buffer();

    // Write the certificate_request_context with a 1-byte length prefix.
    buffer.pushVector(certificateRequestContext, 1);

    // Serialize all certificate entries into a temporary buffer.
    final certListBuffer = Buffer();
    for (final entry in certificateList) {
      certListBuffer.pushBytes(entry.toBytes());
    }

    // Write the serialized certificate list with a 3-byte length prefix.
    buffer.pushVector(certListBuffer.toBytes(), 3);

    return buffer.toBytes();
  }

  @override
  String toString() =>
      'Certificate(context_len: ${certificateRequestContext.length}, certs: ${certificateList})';
}

void main() {
  final buffer = Buffer(data: certificateBytes);
  final msgType = buffer.pullUint8();
  final length = buffer.pullUint24();
  final messageBody = buffer.pullBytes(length);
  final certificate = Certificate.fromBytes(Buffer(data: messageBody));
  print("Certificate: $certificate");
  print("Certificate: ${HEX.encode(certificate.toBytes())}");
  print("Expected:    ${HEX.encode(messageBody)}");
}

final certificateBytes = Uint8List.fromList([
  0x0B,
  0x00,
  0x01,
  0xB9,
  0x00,
  0x00,
  0x01,
  0xB5,
  0x00,
  0x01,
  0xB0,
  0x30,
  0x82,
  0x01,
  0xAC,
  0x30,
  0x82,
  0x01,
  0x15,
  0xA0,
  0x03,
  0x02,
  0x01,
  0x02,
  0x02,
  0x01,
  0x02,
  0x30,
  0x0D,
  0x06,
  0x09,
  0x2A,
  0x86,
  0x48,
  0x86,
  0xF7,
  0x0D,
  0x01,
  0x01,
  0x0B,
  0x05,
  0x00,
  0x30,
  0x0E,
  0x31,
  0x0C,
  0x30,
  0x0A,
  0x06,
  0x03,
  0x55,
  0x04,
  0x03,
  0x13,
  0x03,
  0x72,
  0x73,
  0x61,
  0x30,
  0x1E,
  0x17,
  0x0D,
  0x31,
  0x36,
  0x30,
  0x37,
  0x33,
  0x30,
  0x30,
  0x31,
  0x32,
  0x33,
  0x35,
  0x39,
  0x5A,
  0x17,
  0x0D,
  0x32,
  0x36,
  0x30,
  0x37,
  0x33,
  0x30,
  0x30,
  0x31,
  0x32,
  0x33,
  0x35,
  0x39,
  0x5A,
  0x30,
  0x0E,
  0x31,
  0x0C,
  0x30,
  0x0A,
  0x06,
  0x03,
  0x55,
  0x04,
  0x03,
  0x13,
  0x03,
  0x72,
  0x73,
  0x61,
  0x30,
  0x81,
  0x9F,
  0x30,
  0x0D,
  0x06,
  0x09,
  0x2A,
  0x86,
  0x48,
  0x86,
  0xF7,
  0x0D,
  0x01,
  0x01,
  0x01,
  0x05,
  0x00,
  0x03,
  0x81,
  0x8D,
  0x00,
  0x30,
  0x81,
  0x89,
  0x02,
  0x81,
  0x81,
  0x00,
  0xB4,
  0xBB,
  0x49,
  0x8F,
  0x82,
  0x79,
  0x30,
  0x3D,
  0x98,
  0x08,
  0x36,
  0x39,
  0x9B,
  0x36,
  0xC6,
  0x98,
  0x8C,
  0x0C,
  0x68,
  0xDE,
  0x55,
  0xE1,
  0xBD,
  0xB8,
  0x26,
  0xD3,
  0x90,
  0x1A,
  0x24,
  0x61,
  0xEA,
  0xFD,
  0x2D,
  0xE4,
  0x9A,
  0x91,
  0xD0,
  0x15,
  0xAB,
  0xBC,
  0x9A,
  0x95,
  0x13,
  0x7A,
  0xCE,
  0x6C,
  0x1A,
  0xF1,
  0x9E,
  0xAA,
  0x6A,
  0xF9,
  0x8C,
  0x7C,
  0xED,
  0x43,
  0x12,
  0x09,
  0x98,
  0xE1,
  0x87,
  0xA8,
  0x0E,
  0xE0,
  0xCC,
  0xB0,
  0x52,
  0x4B,
  0x1B,
  0x01,
  0x8C,
  0x3E,
  0x0B,
  0x63,
  0x26,
  0x4D,
  0x44,
  0x9A,
  0x6D,
  0x38,
  0xE2,
  0x2A,
  0x5F,
  0xDA,
  0x43,
  0x08,
  0x46,
  0x74,
  0x80,
  0x30,
  0x53,
  0x0E,
  0xF0,
  0x46,
  0x1C,
  0x8C,
  0xA9,
  0xD9,
  0xEF,
  0xBF,
  0xAE,
  0x8E,
  0xA6,
  0xD1,
  0xD0,
  0x3E,
  0x2B,
  0xD1,
  0x93,
  0xEF,
  0xF0,
  0xAB,
  0x9A,
  0x80,
  0x02,
  0xC4,
  0x74,
  0x28,
  0xA6,
  0xD3,
  0x5A,
  0x8D,
  0x88,
  0xD7,
  0x9F,
  0x7F,
  0x1E,
  0x3F,
  0x02,
  0x03,
  0x01,
  0x00,
  0x01,
  0xA3,
  0x1A,
  0x30,
  0x18,
  0x30,
  0x09,
  0x06,
  0x03,
  0x55,
  0x1D,
  0x13,
  0x04,
  0x02,
  0x30,
  0x00,
  0x30,
  0x0B,
  0x06,
  0x03,
  0x55,
  0x1D,
  0x0F,
  0x04,
  0x04,
  0x03,
  0x02,
  0x05,
  0xA0,
  0x30,
  0x0D,
  0x06,
  0x09,
  0x2A,
  0x86,
  0x48,
  0x86,
  0xF7,
  0x0D,
  0x01,
  0x01,
  0x0B,
  0x05,
  0x00,
  0x03,
  0x81,
  0x81,
  0x00,
  0x85,
  0xAA,
  0xD2,
  0xA0,
  0xE5,
  0xB9,
  0x27,
  0x6B,
  0x90,
  0x8C,
  0x65,
  0xF7,
  0x3A,
  0x72,
  0x67,
  0x17,
  0x06,
  0x18,
  0xA5,
  0x4C,
  0x5F,
  0x8A,
  0x7B,
  0x33,
  0x7D,
  0x2D,
  0xF7,
  0xA5,
  0x94,
  0x36,
  0x54,
  0x17,
  0xF2,
  0xEA,
  0xE8,
  0xF8,
  0xA5,
  0x8C,
  0x8F,
  0x81,
  0x72,
  0xF9,
  0x31,
  0x9C,
  0xF3,
  0x6B,
  0x7F,
  0xD6,
  0xC5,
  0x5B,
  0x80,
  0xF2,
  0x1A,
  0x03,
  0x01,
  0x51,
  0x56,
  0x72,
  0x60,
  0x96,
  0xFD,
  0x33,
  0x5E,
  0x5E,
  0x67,
  0xF2,
  0xDB,
  0xF1,
  0x02,
  0x70,
  0x2E,
  0x60,
  0x8C,
  0xCA,
  0xE6,
  0xBE,
  0xC1,
  0xFC,
  0x63,
  0xA4,
  0x2A,
  0x99,
  0xBE,
  0x5C,
  0x3E,
  0xB7,
  0x10,
  0x7C,
  0x3C,
  0x54,
  0xE9,
  0xB9,
  0xEB,
  0x2B,
  0xD5,
  0x20,
  0x3B,
  0x1C,
  0x3B,
  0x84,
  0xE0,
  0xA8,
  0xB2,
  0xF7,
  0x59,
  0x40,
  0x9B,
  0xA3,
  0xEA,
  0xC9,
  0xD9,
  0x1D,
  0x40,
  0x2D,
  0xCC,
  0x0C,
  0xC8,
  0xF8,
  0x96,
  0x12,
  0x29,
  0xAC,
  0x91,
  0x87,
  0xB4,
  0x2B,
  0x4D,
  0xE1,
  0x00,
  0x00,
]);
